#' simulate_counts
#'
#' Function to simulate damaged cells by perturbing the gene expression of
#' existing cells.
#'
#' `DamageDetective` models damage in single-cell RNA sequencing data as the
#' loss of cytoplasmic RNA, where cells experiencing greater RNA loss are assumed
#' to be more extensively damaged, while those with minimal loss are considered
#' largely intact. The perturbation process introduces RNA loss into existing
#' cells and is controlled by three key parameters: the **target proportion of
#' damage**,  which specifies the fraction of cells to be perturbed; the
#' **target level of damage**, which defines the extent of RNA loss across
#' cells; and the **target distribution of damage**, which determines how the
#' different levels of RNA loss are distributed across cells.
#'
#' Based on these parameters, cells are randomly selected and assigned a target
#' proportion of RNA loss. The total number of transcripts to be removed is
#' determined, and perturbation is applied through weighted sampling without
#' replacement from cytoplasmic gene counts. Here, the probability of
#' transcript loss is determined by gene abundance, with highly expressed genes
#' more likely to lose transcripts. Once the target RNA loss is reached, the
#' cell's expression profile is updated, and the process repeats for all
#' selected cells.
#'
#' @param count_matrix Matrix or dgCMatrix containing the counts from
#'  single cell RNA sequencing data.
#' @param damage_proportion Numeric describing what proportion
#'  of the input data should be altered to resemble damaged data.
#'
#'  * Must range between 0 and 1.
#' @param annotated_celltypes Boolean specifying whether input matrix has
#'  cell type information stored.
#'
#'  * Default is FALSE
#' @param target_damage Numeric vector specifying the upper and lower range of
#'  the level of damage that will be introduced.
#'
#'  Here, damage refers to the amount of cytoplasmic RNA lost by a cell where
#'  values closer to 1 indicate more loss and therefore more heavily damaged
#'  cells.
#'
#'  * Default is c(0.1, 0.8)
#' @param damage_distribution String specifying whether the distribution of
#'  damage levels among the damaged cells should be shifted towards the
#'  upper or lower range of damage specified in 'target_damage' or follow
#'  a symmetric distribution between them. There are three valid options:
#'
#'  * "right_skewed"
#'  * "left_skewed"
#'  * "symmetric"
#'
#'  * Default is "right_skewed"
#' @param distribution_steepness String specifying how concentrated the spread of
#'  damaged cells are about the mean of the target distribution specified in
#'  'target_damage'. Here, an increase in steepness manifests in a more
#'  apparent skewness.There are three valid options:
#'
#'  * "shallow"
#'  * "moderate"
#'  * "steep"
#'
#'  * Default is "moderate"
#' @param beta_shape_parameters Numeric vector that allows for the shape
#'   parameters of the beta distribution to defined explicitly. This offers
#'   greater flexibility than allowed by the 'damage_distribution' and
#'   'distribution_steepness' parameters and will override the defaults they
#'   offer.
#'
#'   * Default is 'NULL'
#' @param ribosome_penalty Numeric specifying the factor by which the
#'  probability of loosing a transcript from a ribosomal gene is multiplied by.
#'  Here, values closer to 0 represent a greater penalty.
#'
#'  * Default is 0.01.
#' @param generate_plot Boolean specifying whether the output QC plot should
#'  be outputted. QC plots will be generated by default as we recommend
#'  verifying the perturbed data retains characteristics of true
#'  single cell data.
#'
#'  * Default is TRUE.
#' @param organism String specifying the organism of origin of the input
#'  data where there are two standard options,
#'
#'  * "Hsap"
#'  * "Mmus"
#'
#'  If a user wishes to use a non-standard organism they must input a list
#'  containing strings for the patterns to match mitochondrial and ribosomal
#'  genes of the organism. If available, nuclear-encoded genes that are likely
#'  retained in the nucleus, such as in nuclear speckles, must also
#'  be specified. An example for humans is below,
#'
#'  * organism = c(mito_pattern = "^MT-",
#'                 ribo_pattern = "^(RPS|RPL)",
#'                 nuclear <- c("NEAT1","XIST", "MALAT1")
#'
#' * Default is "Hsap"
#' @param seed Numeric specifying the random seed to ensure reproducibility of
#'  the function's output. Setting a seed ensures that the random sampling
#'  and perturbation processes produce the same results when the function
#'  is run multiple times with the same input data and parameters.
#'
#'  * Default is 7.
#' @return A list containing the altered count matrix, a data frame with summary
#'  statistics, and, if specified, a 'ggplot2' object of the quality control
#'  metrics of the alteration.
#' @import ggplot2
#' @importFrom stats rbeta
#' @import patchwork
#' @importFrom ggpubr get_legend
#' @importFrom cowplot ggdraw draw_label plot_grid
#' @keywords Simulation
#' @export
#' @examples
#' data("test_counts", package = "DamageDetective")
#'
#' simulated_damage <- simulate_counts(
#'   count_matrix = test_counts,
#'   damage_proportion = 0.1,
#'   ribosome_penalty = 0.01,
#'   target_damage = c(0.5, 0.9),
#'   generate_plot = FALSE
#' )
simulate_counts <- function(
    count_matrix,
    damage_proportion,
    annotated_celltypes = FALSE,
    target_damage = c(0.1, 0.8),
    damage_distribution = "right_skewed",
    distribution_steepness = "moderate",
    beta_shape_parameters = NULL,
    ribosome_penalty = 0.001,
    generate_plot = TRUE,
    seed = 7,
    organism = "Hsap"
) {
  # Data preparations ----

  # Verify inputs
  check_simulate_inputs(
    count_matrix,
    damage_proportion,
    beta_shape_parameters,
    target_damage,
    distribution_steepness,
    damage_distribution,
    ribosome_penalty,
    organism
  )

  # Calculate the total number of damaged cells given the target proportion
  total_cells <- ncol(count_matrix)
  damaged_cell_number <- round(total_cells * damage_proportion)

  # Assign damage levels to the selected cells based on beta distribution

  # Assign the steepness (peak height) to meet target
  steepness_levels <- list(
    shallow = 4,
    moderate = 7,
    steep = 14
  )

  # Retrieve user specified steepness
  steepness_value <- steepness_levels[[distribution_steepness]]


  # Assign shape parameters to achieve target distribution
  if (damage_distribution == "right_skewed") {
    a <- steepness_value * 0.3
    b <- steepness_value * 0.7
  } else if (damage_distribution == "left_skewed") {
    a <- steepness_value * 0.7
    b <- steepness_value * 0.3
  } else if (damage_distribution == "symmetric") {
    a <- steepness_value * 0.5
    b <- steepness_value * 0.5
  }

  # Retrieve exact beta distribution shapes if present
  if (!is.null(beta_shape_parameters)){
    a <- beta_shape_parameters[[1]]
    b <- beta_shape_parameters[[2]]
  }

  # Retrieve genes corresponding to the organism of interest
  gene_idx <- get_organism_indices(count_matrix, organism)

  # Select target cells for perturbation ----

  # Select damaged cells uniformly across cell types
  if (annotated_celltypes){

    # Extract the cell types by removing suffix after the first "_"
    cell_types <- as.factor(sub("_.*", "", colnames(count_matrix)))
    cell_type_counts <- table(cell_types)

    # Check if damage labelling was sound
    if (length(cell_type_counts) <= 1 || length(cell_type_counts) >= 1000){
      stop("Please ensure cell types are assigned correctly.")
    }

    # Calculate and adjust numbers to ensure target reached
    damage_per_type <- round(cell_type_counts * (damage_proportion))
    total_damaged <- sum(damage_per_type)

    if (total_damaged != damaged_cell_number) {
      diff <- damaged_cell_number - total_damaged
      damage_per_type <- damage_per_type + round(diff * damage_per_type / sum(damage_per_type))
    }

    # Select the calculated number of damaged cells from each cell type
    damaged_cell_selections <- unlist(lapply(names(damage_per_type), function(ct) {
      cells_of_type <- which(cell_types == ct)
      sample(cells_of_type, size = damage_per_type[ct], replace = FALSE)
    }))

    # Make the column names unique (no longer need the cell types)
    colnames(count_matrix) <- paste0(colnames(count_matrix), "_", seq_len(dim(count_matrix)[2])) # Keep cell types but ensure uniqueness

  } else {

    # If no cell types were specified, cells are sampled randomly
    damaged_cell_selections <- sample(seq_len(total_cells), damaged_cell_number, replace = FALSE)

  }

  # Storage of damage labels for the cell barcodes for plotting
  damage_status <- rep("control", total_cells)
  damage_status[damaged_cell_selections] <- "damaged"
  damage_label <- data.frame(
    barcode = colnames(count_matrix),
    status = damage_status,
    stringsAsFactors = FALSE
  )

  # Consolidate into target beta distribution
  damage_levels <- stats::rbeta(length(damaged_cell_selections), shape1 = a, shape2 = b)

  # Scale values to lie within target range
  damage_levels <- target_damage[1] + (target_damage[2] - target_damage[1]) * damage_levels

  # Store the assigned damage levels in a data frame
  damage_label$damage_level <- 0
  damaged_cells <- match(colnames(count_matrix)[damaged_cell_selections], damage_label$barcode)
  damage_label$damage_level[damaged_cells] <- damage_levels

  # Perturb selected cells ----

  # Initialize for storing modified count_matrix
  damaged_count_matrix <- count_matrix

  for (i in seq_along(damaged_cell_selections)) {
    cell <- damaged_cell_selections[i]

    # Determine number of transcripts to lose
    cell_damage_level <- damage_label$damage_level[match(colnames(count_matrix)[cell], damage_label$barcode)]
    total_count <- sum(damaged_count_matrix[gene_idx$non_mito_idx, cell])
    total_loss <- round(cell_damage_level * total_count)

    # Expand genes into transcript-level representations
    transcripts <- rep(gene_idx$non_mito_idx, times = damaged_count_matrix[gene_idx$non_mito_idx, cell])

    # Assign probability of loss based on gene abundance
    gene_totals <- damaged_count_matrix[gene_idx$non_mito_idx, cell]
    probabilities <- gene_totals / total_count

    # Apply penalty to ribosomal genes and normalize
    probabilities[gene_idx$ribo_idx] <- probabilities[gene_idx$ribo_idx] * ribosome_penalty
    probabilities <- probabilities / sum(probabilities)

    # Replicate probabilities for each transcript
    prob_repeated <- rep(probabilities, times = gene_totals)

    # Sample transcripts to be lost
    lost_transcripts <- sample(transcripts, size = total_loss, replace = FALSE, prob = prob_repeated)

    # Sum remaining transcripts per gene
    remaining_counts <- table(factor(transcripts[!transcripts %in% lost_transcripts], levels = gene_idx$non_mito_idx))

    # Update count matrix
    damaged_count_matrix[gene_idx$non_mito_idx, cell] <- as.integer(remaining_counts)
  }

  # Consolidate & plot simulation output ----

  # Isolate indices for correct ordering of damage status
  matched_indices <- match(colnames(damaged_count_matrix), damage_label$barcode)

  # Generate qc_summary with numeric values
  qc_summary <- data.frame(
    Cell = colnames(count_matrix),
    Damaged_Level = as.numeric(damage_label$damage_level[matched_indices]),
    Original_Features = as.numeric(colSums(count_matrix != 0)),
    New_Features = as.numeric(colSums(damaged_count_matrix != 0)),
    Original_MitoProp = as.numeric(colSums(count_matrix[gene_idx$mito_idx, , drop = FALSE]) / colSums(count_matrix)),
    New_MitoProp = as.numeric(colSums(damaged_count_matrix[gene_idx$mito_idx, , drop = FALSE]) / colSums(damaged_count_matrix)),
    Original_RiboProp = as.numeric(colSums(count_matrix[gene_idx$ribo_idx, , drop = FALSE]) / colSums(count_matrix)),
    New_RiboProp = as.numeric(colSums(damaged_count_matrix[gene_idx$ribo_idx, , drop = FALSE]) / colSums(damaged_count_matrix))
  )

  if (generate_plot){

    # Generate plot before and after perturbation
    final_plot <- plot_simulation_outcome(qc_summary)
    print(final_plot)

    # Return a list containing plot
    return(list(
      matrix = damaged_count_matrix,
      qc_summary = qc_summary,
      plot = final_plot)
    )

  }

  # Else return without plot
  return(list(
    matrix = damaged_count_matrix,
    qc_summary = qc_summary
  )
  )

}
