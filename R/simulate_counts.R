#' simulate_counts
#'
#' Introduce cells with a damage-like gene expression profile into
#' existing single cell data by perturbing a target proportion of the existing
#' cells. Here, we define a damaged cell as that which has experienced a loss
#' in cytoplasmic RNA. Cells with a greater loss are assumed to be more
#' extensively damaged than cells where little RNA has been lost.
#'
#' @param count_matrix Matrix or dgCMatrix containing the counts from
#'  single cell RNA sequencing data.
#' @param damage_proportion Numeric describing what proportion
#'  of the input data should be altered to resemble damaged data.
#'
#'  * Must range between 0 and 1.
#' @param annotated_celltypes Boolean specifying whether input matrix has
#'  cell type information stored.
#'
#'  * Default is FALSE
#' @param target_damage Double numeric specifying the upper and lower range of
#'  the level of damage that will be introduced.
#'
#'  Here, damage refers to the amount of cytoplasmic RNA lost by a cell where
#'  values closer to 1 indicate more loss and therefore more heavily damaged
#'  cells.
#'
#'  * Default is c(0.1, 0.8)
#' @param damage_distribution String specifying whether the distribution of
#'  damage levels among the damaged cells should be shifted towards the
#'  upper or lower range of damage specified in 'target_damage' or follow
#'  a symmetric distribution between them. There are three valid options:
#'
#'  * "right_skewed"
#'  * "left_skewed"
#'  * "symmetric"
#'
#'  * Default is c(0.1, 0.8)
#' @param damage_steepness String specifying how concentrated the spread of
#'  damaged cells are about the mean of the target distribution specified in
#'  'target_damage'. Here, an increase in steepness manifests in a more
#'  apparent skewness.There are three valid options:
#'
#'  * "shallow"
#'  * "moderate"
#'  * "steep"
#'
#'  * Default is "moderate"
#' @param beta_shape_parameters Numeric vector that allows for the shape
#'   parameters of the beta distribution to defined explicitly. This offers
#'   greater flexibility than allowed by the 'damage_distribution' and
#'   'damage_steepness' parameters and will override the defaults they
#'   offer.
#'
#'   * Default is 'NULL'
#' @param ribosome_penalty Numeric specifying the factor by which the
#'  probability of loosing a transcript from a ribosomal gene is multiplied by.
#'  Here, values closer to 0 represent a greater penalty.
#'
#'  * Default is 0.01.
#' @param save_plot String specifying the directory where the output QC plot can
#'  be stored. QC plots will be generated by default as we recommend verifying
#'  the perturbed data retains characteristics of true single cell data. To
#'  prevent plotting, use 'NULL'.
#'
#'  * Default is the temp.dir().
#' @param plot_type String specifying what type of image format the plot
#'  should be saved as. There are two options,
#'
#'  * 'png'
#'  * 'svg'
#'
#'  * Default is 'png'.
#' @param organism String specifying the organism of origin of the input
#'  data where there are two standard options,
#'
#'  * "Hsap"
#'  * "Mmus"
#'
#'  If a user wishes to use a non-standard organism they must input a list
#'  containing strings for the patterns to match mitochondrial and ribosomal
#'  genes of the organism. If available, nuclear-encoded genes that are likely
#'  retained in the nucleus, such as in nuclear speckles, must also
#'  be specified. An example for humans is below,
#'
#'  * organism = c(mito_pattern = "^MT-",
#'                 ribo_pattern = "^(RPS|RPL)",
#'                 nuclear <- c("NEAT1","XIST", "MALAT1")
#'
#' * Default is "Hsap"
#' @return A list containing the altered count matrix, a data frame with summary
#'  statistics, and, if specified, a 'ggplot2' object of the quality control
#'  metrics of the alteration.
#' @import ggplot2
#' @import stats
#' @import patchwork
#' @importFrom ggpubr get_legend
#' @importFrom cowplot ggdraw draw_label plot_grid
#' @export
#' @examples
#' data("test_counts", package = "DamageDetective")
#'
#' simulated_damage <- simulate_counts(
#' count_matrix = test_counts,
#' damage_proportion = 0.5,
#' ribosome_penalty = 0.5,
#' target_damage = c(0.5, 0.9)
#' )
simulate_counts <- function(
    count_matrix,
    damage_proportion,
    annotated_celltypes = FALSE,
    target_damage = c(0.1, 0.8),
    damage_distribution = "right_skewed",
    damage_steepness = "moderate",
    beta_shape_parameters = NULL,
    ribosome_penalty = 0.01,
    save_plot = tempdir(),
    plot_type = "png",
    organism = "Hsap"
) {
  # Phase One: Data preparations ----

  # Check that required inputs are given and in the correct format
  if (is.null(count_matrix)) stop("Please provide 'count_matrix' input.")
  if (is.null(damage_proportion)) stop("Please provide 'damage_proportion'.")
  if (!inherits(count_matrix, "matrix") & !inherits(count_matrix, "CsparseMatrix")) {
    stop("Please ensure 'count_matrix' is a matrix or a sparse matrix (dgCMatrix).")
  }
  if (!is.numeric(damage_proportion) || damage_proportion < 0 || damage_proportion > 1) {
    stop("Please ensure 'damage_proportion' is a numeric between 0 and 1.")
  }

  # Ensure user adjustments to default parameters are executable
  if (!is.numeric(target_damage) || length(target_damage) != 2 || target_damage[1] < 0 || target_damage[2] > 1 || target_damage[1] >= target_damage[2]) {
    stop("Please ensure 'target_damage' is a numeric vector of length 2, with values between 0 and 1, and the first value is less than the second.")
  }
  if (!damage_steepness %in% c("shallow", "moderate", "steep")) {
    stop("Please ensure 'damage_steepness' is one of 'shallow', 'moderate', or 'steep'.")
  }
  if (!damage_distribution %in% c("right_skewed", "left_skewed", "symmetric")) {
    stop("Please ensure 'damage_distribution' is one of 'right_skewed', 'left_skewed', or 'symmetric'.")
  }
  if (!is.numeric(ribosome_penalty) || ribosome_penalty < 0 || ribosome_penalty > 1) {
    stop("Please ensure 'ribosome_penalty' is a numeric between 0 and 1.")
  }
  if (!organism %in% c("Hsap", "Mmus") & length(organism) != 3) {
    stop("Please ensure 'organism' is one of 'Hsap' or 'Mmus', see documentation for non-standard organisms.")
  }

  # Ensure matrix is of 'matrix' form
  count_matrix <- as.matrix(count_matrix)

  # Calculate the total number of damaged cells given the target proportion
  total_cells <- ncol(count_matrix)
  damaged_cell_number <- round(total_cells * damage_proportion)

  # Assign damage levels to the selected cells based on beta distribution
  # Assign the steepness (peak height) to meet target
  steepness_levels <- list(
    shallow = 4,
    moderate = 7,
    steep = 14
  )

  # Retrieve user specified steepness
  steepness_value <- steepness_levels[[damage_steepness]]

  # Assign shape parameters to achieve target distribution
  if (damage_distribution == "right_skewed") {
    a <- steepness_value * 0.3
    b <- steepness_value * 0.7
  } else if (damage_distribution == "left_skewed") {
    a <- steepness_value * 0.7
    b <- steepness_value * 0.3
  } else if (damage_distribution == "symmetric") {
    a <- steepness_value * 0.5
    b <- steepness_value * 0.5
  }

  # Retrieve exact beta distribution shapes if present
  if (!is.null(beta_shape_parameters)){
    a <- beta_shape_parameters[[1]]
    b <- beta_shape_parameters[[2]]
  }

  # Retrieve genes corresponding to the organism of interest

  # Human
  if (organism == "Hsap") {
    mito_pattern <- "^MT-"
    ribo_pattern <- "^(RPS|RPL)"
    nuclear <- c("FIRRE", "NEAT1","XIST", "MALAT1", "MIAT", "MEG3", "KCNQ1OT1", "HOXA11-AS", "FTX")
  }

  # Mouse
  if (organism == "Mmus") {
    mito_pattern <- "^mt-"
    ribo_pattern <- "^(rps|rpl)"
    nuclear <- c("Firre", "Neat1","Xist", "Malat1", "Miat", "Meg3", "Kcnq1ot1", "Hoxa11-as", "Ftx")
  }

  # Allow for user specification for non-standard organism
  if (!organism %in% c("Hsap", "Mmus")) {
    mito_pattern <- organism$mito_pattern
    ribo_pattern <- organism$ribo_pattern
    nuclear <- organism$nuclear
  }

  # Isolate gene set indices (consistent across cells, not subsetting the matrix)
  mito_idx <- grep(mito_pattern, rownames(count_matrix), ignore.case = FALSE)
  nucl_idx <- which(rownames(count_matrix) %in% nuclear)
  mito_idx <- c(mito_idx, nucl_idx)
  non_mito_idx <- setdiff(seq_len(nrow(count_matrix)), mito_idx)
  ribo_idx <- grep(ribo_pattern, rownames(count_matrix), ignore.case = FALSE)

  # Phase Two: Select target cells ----

  # Select damaged cells uniformly across cell types
  if (annotated_celltypes){

    # Extract the cell types by removing suffix after the first "_"
    cell_types <- as.factor(sub("_.*", "", colnames(count_matrix)))
    cell_type_counts <- table(cell_types)

    # Check if damage labelling was sound
    if (length(cell_type_counts) <= 1 || length(cell_type_counts) >= 1000){
      stop("Please ensure cell types are assigned correctly.")
    }

    # Calculate and adjust numbers to ensure target reached
    damage_per_type <- round(cell_type_counts * (damage_proportion))
    total_damaged <- sum(damage_per_type)

    if (total_damaged != damaged_cell_number) {
      diff <- damaged_cell_number - total_damaged
      damage_per_type <- damage_per_type + round(diff * damage_per_type / sum(damage_per_type))
    }

    # Select the calculated number of damaged cells from each cell type
    damaged_cell_selections <- unlist(lapply(names(damage_per_type), function(ct) {
      cells_of_type <- which(cell_types == ct)
      sample(cells_of_type, size = damage_per_type[ct], replace = FALSE)
    }))

    # Make the column names unique (no longer need the cell types)
    colnames(count_matrix) <- paste0(colnames(count_matrix), "_", seq_len(dim(count_matrix)[2])) # Keep cell types but ensure uniqueness

  } else {

    # If no cell types were specified, cells are sampled randomly
    damaged_cell_selections <- sample(seq_len(total_cells), damaged_cell_number)

  }

  # Storage of damage labels for the cell barcodes for plotting
  damage_status <- rep("control", total_cells)
  damage_status[damaged_cell_selections] <- "damaged"
  damage_label <- data.frame(
    barcode = colnames(count_matrix),
    status = damage_status,
    stringsAsFactors = FALSE
  )

  # Consolidate into target beta distribution
  damage_levels <- stats::rbeta(length(damaged_cell_selections), shape1 = a, shape2 = b)

  # Scale values to lie within target range
  damage_levels <- target_damage[1] + (target_damage[2] - target_damage[1]) * damage_levels

  # Store the assigned damage levels in a data frame
  damage_label$damage_level <- 0
  damaged_cells <- match(colnames(count_matrix)[damaged_cell_selections], damage_label$barcode)
  damage_label$damage_level[damaged_cells] <- damage_levels

  # Phase Three: Perturb selected cells ----

  # Initialize for storing modified count_matrix
  damaged_count_matrix <- as.matrix(count_matrix)

  for (i in seq_along(damaged_cell_selections)) {
    cell <- damaged_cell_selections[i]

    # Determine number of transcripts to lose
    cell_damage_level <- damage_label$damage_level[match(colnames(count_matrix)[cell], damage_label$barcode)]
    total_count <- sum(damaged_count_matrix[non_mito_idx, cell])
    total_loss <- round(cell_damage_level * total_count)

    # Expand genes into transcript-level representations
    transcripts <- rep(non_mito_idx, times = damaged_count_matrix[non_mito_idx, cell])

    # Assign probability of loss based on gene abundance
    gene_totals <- damaged_count_matrix[non_mito_idx, cell]
    probabilities <- gene_totals / total_count

    # Apply penalty to ribosomal genes and normalize
    probabilities[ribo_idx] <- probabilities[ribo_idx] * ribosome_penalty
    probabilities <- probabilities / sum(probabilities)

    # Replicate probabilities for each transcript
    prob_repeated <- rep(probabilities, times = gene_totals)

    # Sample transcripts to be lost
    lost_transcripts <- sample(transcripts, size = total_loss, replace = FALSE, prob = prob_repeated)

    # Sum remaining transcripts per gene
    remaining_counts <- table(factor(transcripts[!transcripts %in% lost_transcripts], levels = non_mito_idx))

    # Update count matrix
    damaged_count_matrix[non_mito_idx, cell] <- as.integer(remaining_counts)
  }

  # Phase Four: Organise & plot output ----

  # Isolate indices for correct ordering of damage status
  matched_indices <- match(colnames(damaged_count_matrix), damage_label$barcode)

  # Generate qc_summary with numeric values
  qc_summary <- data.frame(
    Cell = colnames(count_matrix),
    Damaged_Level = as.numeric(damage_label$damage_level[matched_indices]),
    Original_Features = as.numeric(colSums(count_matrix != 0)),
    New_Features = as.numeric(colSums(damaged_count_matrix != 0)),
    Original_MitoProp = as.numeric(colSums(count_matrix[mito_idx, , drop = FALSE]) / colSums(count_matrix)),
    New_MitoProp = as.numeric(colSums(damaged_count_matrix[mito_idx, , drop = FALSE]) / colSums(damaged_count_matrix)),
    Original_RiboProp = as.numeric(colSums(count_matrix[ribo_idx, , drop = FALSE]) / colSums(count_matrix)),
    New_RiboProp = as.numeric(colSums(damaged_count_matrix[ribo_idx, , drop = FALSE]) / colSums(damaged_count_matrix))
  )

  # Generate plot before and after perturbation if specified
  if (!is.null(save_plot)){

    # Generate individual plots
    mito_ribo_old <- plot_outcome(qc_summary, x = "Original_RiboProp", y = "Original_MitoProp", mito_ribo = TRUE, target_damage = target_damage)
    mito_ribo_new <- plot_outcome(qc_summary, x = "New_RiboProp", y = "New_MitoProp", altered = TRUE, mito_ribo = TRUE, target_damage = target_damage)
    mito_features_old <- plot_outcome(qc_summary, x = "Original_Features", y = "Original_MitoProp", target_damage = target_damage)
    mito_features_new <- plot_outcome(qc_summary, x = "New_Features", y = "New_MitoProp", altered = TRUE, target_damage = target_damage)

    # Extract the legend from mito_ribo_new
    legend <- ggpubr::get_legend(mito_ribo_new)

    # Create titles for the plots
    title_original <- cowplot::ggdraw() +
      cowplot::draw_label("Original count_matrix", fontface = 'bold', hjust = 0.5)

    title_altered <- cowplot::ggdraw() +
      cowplot::draw_label("Altered count_matrix", fontface = 'bold', hjust = 0.5)

    # Arrange original plots in a single row
    original_plots <- cowplot::plot_grid(mito_features_old, mito_ribo_old, ncol = 2)

    # Arrange altered plots in a single row
    mito_ribo_new_no_legend <- mito_ribo_new + ggplot2::theme(legend.position = "none")
    mito_features_new_no_legend <- mito_features_new + ggplot2::theme(legend.position = "none")
    altered_plots <- cowplot::plot_grid(mito_features_new_no_legend, mito_ribo_new_no_legend, ncol = 2)

    # Combine the original and altered rows with their titles
    original_with_title <- cowplot::plot_grid(title_original, original_plots, ncol = 1, rel_heights = c(0.2, 1))
    altered_with_title <- cowplot::plot_grid(title_altered, altered_plots, ncol = 1, rel_heights = c(0.2, 1))

    # Combine the original and altered rows, and position the legend in its own row
    final_plot <- cowplot::plot_grid(
      original_with_title,
      altered_with_title,
      legend,
      ncol = 1,
      rel_heights = c(1, 1, 0.25)
    )

    # Increase margins around the total plot area
    final_plot <- final_plot +
      ggplot2::theme(
        plot.margin = ggplot2::margin(10, 20, 20, 20),  # top, right, bottom, left
        panel.background = ggplot2::element_rect(fill = "white", color = "white"),
        plot.background = ggplot2::element_rect(fill = "white", color = "white")  # Ensure the plot background is white
      )

    # Display the final plot
    print(final_plot)

    # Save the final plot to a specified directory
    output_file <- file.path(save_plot, paste0("Simulation_QC.", plot_type))

    # Use ggsave to save the plot
    if (plot_type == "png") {
      ggplot2::ggsave(
        output_file,
        plot = final_plot,
        width = 8,
        height = 8,
        dpi = 300,
        units = "in"
      )
    } else if (plot_type == "svg") {
      ggplot2::ggsave(
        output_file,
        plot = final_plot,
        width = 8,
        height = 8,
        units = "in"
      )
    }

    # Return a list containing plot
    return(list(
      matrix = damaged_count_matrix,
      qc_summary = qc_summary,
      plot = final_plot)
    )
  }

  # Else return without plot
  return(list(
    matrix = damaged_count_matrix,
    qc_summary = qc_summary
  )
  )

}


