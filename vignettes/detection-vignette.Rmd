---
title: "Damage cell quality control"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Damage cell quality control}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Tutorial overview

The goal of `DamageDetective` is to simplify the process of making informed and reproducible damaged cell filtering decisions in scRNA-seq pre-processing. This tutorial provides an outline of the steps needed to achieve this with `DamageDetective`,\

-   Data preparation
-   Parameter selection
-   Damaged cell detection

Ensure the following packages are installed and made available in your R environment to follow along with the tutorial.

-   [DamageDetective](https://github.com/AlicenJoyHenning/DamageDetective), [SeuratData](https://github.com/satijalab/seurat-data), [Seurat](https://github.com/satijalab/seurat), [scRNAseq](https://bioconductor.org/packages/release/data/experiment/html/scRNAseq.html)
, and [SingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html).

```{r, include=FALSE, message=FALSE, warning=FALSE}

library("Seurat")
library("SingleCellExperiment")
library("scRNAseq")

# invisible(lapply(c("Seurat", "SingleCellExperiment", "scRNAseq"), library, character.only = TRUE))


```


<br>


## Data preparation

The entirety of this tutorial will take place in `R`, home to three popular scRNA-seq data storage types,

-   `Seurat` object

-   `SingleCellExperiment` (`sce`) class

-   Or directly as a matrix compiled from the alignment output, `matrix.mtx`, `barcodes.tsv`, and `features.tsv`.


`DamageDetective` operates with data in a compressed, column-oriented sparse matrix (dgCMatrix). This format efficiently handles the sparse nature of single-cell data by indexing only nonzero elements within each column. As the damage simulation at the core of `DamageDetective` involves multiple column-wise operations, this is the preferred input format.

Each of the above data types can act as the starting point to damage detection through conversion to a sparse matrix.


### `Seurat` object

We will use the `SeuratData` package to retrieve a publicly available `Seurat` object for demonstration. This object stores the data from peripheral blood mononuclear cells, or PBMCs, sequenced using the 10X Genomics platform.

```{r eval=FALSE, seurat_data}
# Retrieve the dataset of interest
SeuratData::InstallData("pbmc3k")
data("pbmc3k")
```

```{r echo=FALSE, retrieve_seurat}
# Circumventing the inability of the vignette to load directly from SeuratData
url <- "https://zenodo.org/records/15117856/files/pbmc3k.rds?download=1"

# Downlaod file from temp path
temp_file <- file.path(tempdir(), "pbmc3k.rds")
download.file(url, temp_file, mode = "wb")
pbmc3k <- readRDS(temp_file)

```

Upon loading, we see the `Seurat` object contains 2700 cells and 13 714 features. The count matrix can be extracted from the assay slot of the object which, by default, is already in compressed column-oriented sparse form. The counts can now be used as input for `DamageDetective`. 

```{r}
# View dimensions & class
class(pbmc3k)[1]
dim(pbmc3k)
 
# Extract the count matrix
pbmc3k_counts <- pbmc3k[["RNA"]]$counts

# View data
class(pbmc3k_counts)[1] 
dim(pbmc3k_counts)
```

### Alignment output

We will use publicly available alignment data from the 10X Genomics website for demonstration, specifically the '1k PBMCs from a healthy donor (v3)' data available [here](https://www.10xgenomics.com/datasets/1-k-pbm-cs-from-a-healthy-donor-v-3-chemistry-3-standard-3-0-0) following the link named "Feature / cell matrix (filtered)". 

```{r echo=FALSE, retrieve_alignment}
url <- "https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/pbmc_1k_v3_filtered_feature_bc_matrix.tar.gz"

# Set a temporary directory
temp_dir <- tempdir()
tar_file <- file.path(tempdir(), "pbmc_1k_v3_filtered_feature_bc_matrix.tar.gz")

# Download files
download.file(url, tar_file, mode = "wb", quiet = TRUE)
untar(tar_file, exdir = temp_dir)
extracted_dir <- file.path(temp_dir, "filtered_feature_bc_matrix")
alignment_counts <- Seurat::Read10X(extracted_dir)

```

The alignment output comes in the form of three files containing the row names (genes), column names (cell identifiers), and input values (counts) of the count matrix. These can be compiled using `Seurat`'s `ReadMtx` which simplifies the count matrix compilation into one function. This involves uncompressing zipped files, mapping feature names to HGNC gene symbols, and converting the matrix to sparse format. `ReadMtx` output can be used directly for `DamageDetective`.

```{r eval=FALSE, demonstrate_alignment_conversion}
# Set the file paths relative to location on your device
matrix_file <- "~/Projects/demonstrations/matrix.mtx.gz"     
barcodes_file <- "~/Projects/demonstrations/barcodes.tsv.gz" 
features_file <- "~/Projects/demonstrations/features.tsv.gz" 

# Construct the sparse matrix
alignment_counts <- Seurat::ReadMtx(
  mtx = matrix_file,
  cells = barcodes_file,
  features = features_file
)
```

```{r echo=FALSE, clean_temp}
unlink(extracted_dir, recursive = TRUE, force = TRUE)
```

Upon converting, we see this dataset contains 1222 cells and 33 538 genes.

```{r view_output}
# View output
class(alignment_counts)[1]
dim(alignment_counts)
```

### `sce` object

We will use the `scRNAseq` package to retrieve a publicly available `sce` object for demonstration. This object stores PBMC data of multiple samples from a study investigating influenza and yellow fever vaccine responsiveness. We will focus on the "234_d0" sample coming from an individual with a high vaccine responsiveness.

Upon loading, we see the object contains 2358 cells and 32 738 features. The count matrix is stored as a delayed matrix within the assay slot of the `sce` object. This format enables memory-efficient operations by delaying computations until explicitly requested, rather than storing all values in memory upfront. However, `DamageDetective` computations require repeated access to the matrix and delays at each request greatly accumulate to slow down the process. We can convert the delayed matrix to a sparse matrix using a dense matrix intermediate.

```{r sce_data}
# Retrieve multisample dataset
pbmc_sce <- scRNAseq::fetchDataset("kotliarov-pbmc-2020", "2024-04-18")

# Extract barcodes of the sample of interest
metadata <- SummarizedExperiment::colData(pbmc_sce)
sample_sce <- subset(metadata, sample == "234_d0")
sample_sce <- rownames(sample_sce)

# Isolate counts from multisample and subset for sample of interest
pbmc_counts <- SummarizedExperiment::assay(pbmc_sce, "counts")
sample_counts  <- pbmc_counts[, sample_sce]

# Convert delayed to sparse format
sample_counts <- as.matrix(sample_counts)
sample_counts <- as(sample_counts, "dgCMatrix")

# View output
class(sample_counts)[1]
dim(sample_counts)

```

## Parameter selection
Damage detection is carried out by the `detect_damage` function that requires only one input to run, the count matrix, but accepts additional parameters. 

These can be divided into two categories, those that will result in a different output, **computational parameters**, and those that adjust how the user receives the output but cannot change it, **aesthetic parameters**. Each will be explored briefly before making the appropriate selections.

### Computational parameters
**Dataset-defined**  
For some parameters, the choice of input is predetermined by the input data. This includes the `organism` from which the data came and whether the data contains cell type annotations, `annotated_celltypes`. In most cases, these need no alteration from the default (`Hsap` and `FALSE`).

The `ribosome_penalty` parameter is also determined by the input data but requires some work to uncover. This parameter accounts for the unexpectedly lower probability of ribosomal RNA loss observed in real single cell data than what is expected based on transcript abundance alone. This is essential for generating artificial cells.

This can be 



loss of cytoplasmic RNA 




<br>

**Table summarising `detect_damage` parameters** 

| Parameter | Description | Options | Default | Recommendations |
| --- | --- | --- | --- | --- | 
| seed | Number set to make the output of random sampling reproducible | any integer | 7 | - | 











### Aesthetic parameters
This

    organism = "Hsap",
    annotated_celltypes = FALSE,
    target_damage = c(0.1, 0.8),
    damage_distribution = "right_skewed",
    distribution_steepness = "moderate",
    beta_shape_parameters = NULL,


## Damaged cell detection

## Session Information
```{r session-info, echo=FALSE}
sessionInfo()
```


# References

Satija R, Hoffman P, Butler A (2025). *SeuratData: Install and Manage Seurat Datasets*. R package version 0.2.2.9002, commit 3e51f44303069b64f5dc4d68e6a3d4a343f55c39, <https://github.com/satijalab/seurat-data>.
